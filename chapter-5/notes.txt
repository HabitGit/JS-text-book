ЧИСЛА:
Что бы сократить количество нулей используется e:
let billion = 1e9;  // 1 миллиард, буквально: 1 и 9 нулей

let ms = 1e-6; // шесть нулей, слева от 1

Например:

let num = 255;

для вызова метода на число ставится две точки:
alert( 123456..toString(36) ); // 2n9c

синтаксис:
num.toString(base) возвращает строковое представление числа 
num в системе счисления base.
пример:
alert( num.toString(16) );  // ff
alert( num.toString(2) );   // 11111111

math.floor - округление в меньшую сторону.
math.ceil - округление в бульшую сторону.
math.round - округление до ближайшего целого.
math.trunc - удаляет дробную часть

.toFixed(n) - округляет до n знаков после запятой. Так же 
округляет до ближайшего числа.

isNaN(value) преобразует значение в число и проверяет является ли 
оно NaN;

isFinite(value) преобразует аргумент в число и возвращает true, 
если оно является обычным числом, т.е. не NaN/Infinity/-Infinity

Number.isNaN и Number.isFinite - более строгая проверка на number,
они не преобразуют аргументы в число, а проверяют является ли 
аргумент числом;

Object.is(a, b) - сравнивает два значения

parseInt и parseFloat - Они «читают» число из строки. Если в 
процессе чтения возникает ошибка, они возвращают полученное до 
ошибки число. Функция parseInt возвращает целое число, а 
parseFloat возвращает число с плавающей точкой.

Второй аргумент parseInt(str, radix)
Функция parseInt() имеет необязательный второй параметр. Он 
определяет систему счисления, таким образом parseInt может также 
читать строки с шестнадцатеричными числами, двоичными числами и 
т.д.:

alert( parseInt('0xff', 16) ); // 255
alert( parseInt('ff', 16) ); // 255, без 0x тоже работает

alert( parseInt('2n9c', 36) ); // 123456

Math.random() - Возвращает псевдослучайное число в диапазоне 
от 0 (включительно) до 1 (но не включая 1)

Math.max(a, b, c...) / Math.min(a, b, c...) - Возвращает 
наибольшее/наименьшее число из перечисленных аргументов.

Math.pow(n, power) - Возвращает число n, возведённое в степень 
power

СТРОКИ:



Внутренний формат для строк — всегда UTF-16, вне зависимости от 
кодировки страницы.
\n - перевод строки
\ - экранирование кавычек, слеша и т.д.
\t - табуляция
.length - длина строки

Извлечение по индексу в строке:
let str = `Hello`;

// получаем первый символ
alert( str[0] ); // H
alert( str.at(0) ); // H

// получаем последний символ
alert( str[str.length - 1] ); // o
alert( str.at(-1) );

toLowerCase() - меняет регистр на маленький 
toUpperCase() - меняет регистр на большой

Если мы захотим перевести в нижний регистр какой-то конкретный символ:

alert( 'Interface'[0].toLowerCase() ); // 'i'

str.indexOf(substr, pos) - Метод для поиска подстроки.
Он ищет подстроку substr в строке str, начиная с позиции pos, и 
возвращает позицию, на которой располагается совпадение, либо -1 
при отсутствии совпадений.

Что бы найти все вхождения подстроки, нужно запустить indexOf в
цикле:
let str = 'Ослик Иа-Иа посмотрел на виадук';

let target = 'Иа'; // цель поиска

let pos = 0;
while (true) {
  let foundPos = str.indexOf(target, pos);
  if (foundPos == -1) break;

  alert( `Найдено тут: ${foundPos}` );
  pos = foundPos + 1; // продолжаем со следующей позиции
}


str.lastIndexOf(substr, position) - Также есть похожий метод 
str.lastIndexOf(substr, position), который ищет с конца строки к 
её началу. Он используется тогда, когда нужно получить самое 
последнее вхождение: перед концом строки или начинающееся до 
(включительно) определённой позиции.

Для удобства можно использовать побитовый НЕ (~), это то же что и 
-(n + 1)

.includes(substr, pos) - Современный метод поиска подстроки,
substr - значение подстроки
pos - необъязательный аргумент который указывает с какого индекса
начать.

str.startsWith - проверят начинается ли строка с определенного 
значения
str.endsWith - проверяет заканчивается ли строка определенным
значением

str.slice(start [, end]) - первый метод получения подстроки.
Возвращает часть строки от start до (не включая) end.
Если аргумент end отсутствует, slice возвращает символы до конца 
строки

str.substr(start [, length]) - Возвращает часть строки от start 
длины length. В противоположность предыдущим методам, этот 
позволяет указать длину вместо конечной позиции

str.codePointAt(pos) - Возвращает код для символа, находящегося 
на позиции pos

String.fromCodePoint(code) - Создаёт символ по его коду code

str.trim() — убирает пробелы в начале и конце строки.
str.repeat(n) — повторяет строку n раз.

https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String  - справочник по строкам


МАССИВЫ:
 синтаксис:
 let arr = new Array();
let arr = [];

arr.at(i) - это ровно то же самое, что и arr[i], 
если i >= 0 для отрицательных значений i, он отступает от конца 
массива.

arr.pop() - удаляет последний элемент из массива, и так же 
возвращает его.

arr.push() - Добавляет элемент в конец массива

arr.shift() - Удаляет первый элемент из массива и так же возвращает
его.

arr.unshift() - Добавляет элемент в начало массива

for (let fruit of fruits) - так выглядит цикл для перебора массивов
for .. of
Но нету доступа к индексам, по этому в некоторых случаях лучше 
использовать for (let i=0; i<arr.length; i++) 

String(arr) - возвращает строку с элементами разделенными запятой


удаление элементов из массивов:
arr.splice(str) 
синтаксис: arr.splice(start[, deleteCount, elem1, ..., elemN])
Он изменяет arr начиная с индекса start: удаляет deleteCount 
элементов и затем вставляет elem1, ..., elemN на их место. 
Возвращает массив из удалённых элементов.

Пример:
let arr = ["Я", "изучаю", "JavaScript"];
arr.splice(1, 1); // начиная с индекса 1, удалить 1 элемент
alert( arr ); // осталось ["Я", "JavaScript"]

let arr = ["Я", "изучаю", "JavaScript", "прямо", "сейчас"];
// удалить 3 первых элемента и заменить их другими
arr.splice(0, 3, "Давай", "танцевать");
alert( arr ) // теперь ["Давай", "танцевать", "прямо", "сейчас"]

Метод splice также может вставлять элементы без удаления, для 
этого достаточно установить deleteCount в 0:
let arr = ["Я", "изучаю", "JavaScript"];
// с индекса 2
// удалить 0 элементов
// вставить "сложный", "язык"
arr.splice(2, 0, "сложный", "язык");
alert( arr ); // "Я", "изучаю", "сложный", "язык", "JavaScript"


Метод arr.slice намного проще, чем похожий на него arr.splice.
Синтаксис:
arr.slice([start], [end])
Он возвращает новый массив, в который копирует все элементы с 
индекса start до end (не включая end). start и end могут быть 
отрицательными, в этом случае отсчёт позиции будет вестись с 
конца массива.

если не использовать аргументов то просто копирует весь массив

Перебор: forEach
Метод arr.forEach позволяет запускать функцию для каждого элемента 
массива.
Синтаксис:
arr.forEach(function(item, index, array) {
  // ... делать что-то с item
});

Например, этот код выведет на экран каждый элемент массива:
// Вызов alert для каждого элемента
["Бильбо", "Гэндальф", "Назгул"].forEach(alert);

А этот вдобавок расскажет и о позиции элемента в целевом массиве:
["Бильбо", "Гэндальф", "Назгул"].forEach((item, index, array) => {
  alert(`У ${item} индекс ${index} в ${array}`);
});


arr.indexOf и arr.includes одинаковый синтаксис и они делают по 
сути то же самое, что и их строковые аналоги, но работают с 
элементами вместо символов:
arr.indexOf(item, from) ищет item начиная с индекса from и 
возвращает номер индекса, на котором был найден искомый элемент, 
в противном случае -1.
arr.includes(item, from) ищет item начиная с индекса from и 
возвращает true, если поиск успешен.

Например:
let arr = [1, 0, false];
alert( arr.indexOf(0) ); // 1
alert( arr.indexOf(false) ); // 2
alert( arr.indexOf(null) ); // -1
alert( arr.includes(1) ); // true

Метод arr.lastIndexOf похож на indexOf, но ищет справа налево.

let fruits = ['Яблоко', 'Апельсин', 'Яблоко']

alert( fruits.indexOf('Яблоко') ); // 0 (первый 'Яблоко')
alert( fruits.lastIndexOf('Яблоко') ); // 2 (последний 'Яблоко')


метод arr.find. - Ищет объекты с определенным условием
Синтаксис:
let result = arr.find(function(item, index, array) {
  // если true - возвращается текущий элемент и перебор 
  прерывается
  // если все итерации оказались ложными, возвращается undefined
});

Функция вызывается по очереди для каждого элемента массива:
    item – очередной элемент.
    index – его индекс.
    array – сам массив.

let users = [
  {id: 1, name: "Вася"},
  {id: 2, name: "Петя"},
  {id: 3, name: "Маша"}
];

let user = users.find(item => item.id == 1);

alert(user.name); // Вася

У метода arr.findIndex такой же синтаксис, но он возвращает 
индекс, на котором был найден элемент, а не сам элемент. 
Значение -1 возвращается, если ничего не найдено.

Метод arr.findLastIndex похож на findIndex, но ищет справа налево, 
наподобие lastIndexOf.
Например:
let users = [
  {id: 1, name: "Вася"},
  {id: 2, name: "Петя"},
  {id: 3, name: "Маша"},
  {id: 4, name: "Вася"}
];
// Найти индекс первого Васи
alert(users.findIndex(user => user.name == 'Вася')); // 0
// Найти индекс последнего Васи
alert(users.findLastIndex(user => user.name == 'Вася')); // 3


Метод find ищет один (первый) элемент, который заставит функцию 
вернуть true.
Если найденных элементов может быть много, можно использовать 
arr.filter(fn).
Синтаксис схож с find, но filter возвращает массив из всех 
подходящих элементов:
let results = arr.filter(function(item, index, array) {
  // если `true` -- элемент добавляется к results и перебор 
  продолжается
  // возвращается пустой массив в случае, если ничего не найдено
});

Например:
let users = [
  {id: 1, name: "Вася"},
  {id: 2, name: "Петя"},
  {id: 3, name: "Маша"}
];
// возвращает массив, состоящий из двух первых пользователей
let someUsers = users.filter(item => item.id < 3);
alert(someUsers.length); // 2


Метод arr.map является одним из наиболее полезных и часто 
используемых. Он вызывает функцию для каждого элемента массива и 
возвращает массив результатов выполнения этой функции.
Синтаксис:
let result = arr.map(function(item, index, array) {
  // возвращается новое значение вместо элемента
});

Например, здесь мы преобразуем каждый элемент в его длину:
let lengths = ["Бильбо", "Гэндальф", "Назгул"].map(item => item.length);
alert(lengths); // 6,8,6


Вызов arr.sort() сортирует массив на месте, меняя в нём порядок 
элементов. Он также возвращает отсортированный массив, но обычно 
возвращаемое значение игнорируется, так как изменяется сам arr.

Чтобы использовать наш собственный порядок сортировки, нам нужно 
предоставить функцию в качестве аргумента arr.sort().мФункция 
должна для пары значений возвращать:
function compare(a, b) {
  if (a > b) return 1; // если первое значение больше второго
  if (a == b) return 0; // если равны
  if (a < b) return -1; // если первое значение меньше второго
}
Например, для сортировки чисел:
function compareNumeric(a, b) {
  if (a > b) return 1;
  if (a == b) return 0;
  if (a < b) return -1;
}
let arr = [ 1, 2, 15 ];
arr.sort(compareNumeric);
alert(arr);  // 1, 2, 15


Используйте localeCompare для строк
Помните алгоритм сравнения строк? По умолчанию, он сравнивает 
буквы по их кодам.
Для многих алфавитов лучше использовать метод str.localeCompare, 
для правильной сортировки букв, таких как Ö.


Метод arr.reverse меняет порядок элементов в arr на обратный.
Например:
let arr = [1, 2, 3, 4, 5];
arr.reverse();
alert( arr ); // 5,4,3,2,1
Он также возвращает массив arr с изменённым порядком элементов.


Метод str.split(delim) именно это и делает. Он разбивает строку 
на массив по заданному разделителю delim. В примере ниже таким 
разделителем является строка из запятой и пробела.
let names = 'Вася, Петя, Маша';
let arr = names.split(', ');
for (let name of arr) {
  alert( `Сообщение получат: ${name}.` ); // Сообщение получат: Вася (и другие имена)
}
У метода split есть необязательный второй числовой аргумент – 
ограничение на количество элементов в массиве. Если их больше, 
чем указано, то остаток массива будет отброшен. На практике это 
редко используется:
let arr = 'Вася, Петя, Маша, Саша'.split(', ', 2);
alert(arr); // Вася, Петя


Вызов split(s) с пустым аргументом s разбил бы строку на массив 
букв:
let str = "тест";
alert( str.split('') ); // т,е,с,т


Вызов arr.join(glue) делает в точности противоположное split. Он 
создаёт строку из элементов arr, вставляя glue между ними.
Например:
let arr = ['Вася', 'Петя', 'Маша'];
let str = arr.join(';'); // объединить массив в строку через ;
alert( str ); // Вася;Петя;Маша


…Но массивы используются настолько часто, что для этого придумали 
специальный метод: Array.isArray(value). Он возвращает true, 
если value массив, и false, если нет.


Шпаргалка по методам массива:

    Для добавления/удаления элементов:
        push (...items) – добавляет элементы в конец,
        pop() – извлекает элемент с конца,
        shift() – извлекает элемент с начала,
        unshift(...items) – добавляет элементы в начало.
        splice(pos, deleteCount, ...items) – начиная с индекса pos удаляет deleteCount элементов и вставляет items.
        slice(start, end) – создаёт новый массив, копируя в него элементы с индекса start до end (не включая end).
        concat(...items) – возвращает новый массив: копирует все члены текущего массива и добавляет к нему items. Если какой-то из items является массивом, тогда берутся его элементы.

    Для поиска среди элементов:
        indexOf/lastIndexOf(item, pos) – ищет item, начиная с позиции pos, и возвращает его индекс или -1, если ничего не найдено.
        includes(value) – возвращает true, если в массиве имеется элемент value, в противном случае false.
        find/filter(func) – фильтрует элементы через функцию и отдаёт первое/все значения, при прохождении которых через функцию возвращается true.
        findIndex похож на find, но возвращает индекс вместо значения.

    Для перебора элементов:
        forEach(func) – вызывает func для каждого элемента. Ничего не возвращает.

    Для преобразования массива:
        map(func) – создаёт новый массив из результатов вызова func для каждого элемента.
        sort(func) – сортирует массив «на месте», а потом возвращает его.
        reverse() – «на месте» меняет порядок следования элементов на противоположный и возвращает изменённый массив.
        split/join – преобразует строку в массив и обратно.
        reduce/reduceRight(func, initial) – вычисляет одно значение на основе всего массива, вызывая func для каждого элемента и передавая промежуточный результат между вызовами.

    Дополнительно:
        Array.isArray(arr) проверяет, является ли arr массивом.


ПЕРЕБИРАЕМЫЕ ОБЪЕКТЫ:

Symbol.iterator :

let range = {
  from: 1,
  to: 5
};
// 1. вызов for..of сначала вызывает эту функцию
range[Symbol.iterator] = function() {
  // ...она возвращает объект итератора:
  // 2. Далее, for..of работает только с этим итератором, 
  запрашивая у него новые значения
  return {
    current: this.from,
    last: this.to,
    // 3. next() вызывается на каждой итерации цикла for..of
    next() {
      // 4. он должен вернуть значение в виде объекта 
      {done:.., value :...}
      if (this.current <= this.last) {
        return { done: false, value: this.current++ };
      } else {
        return { done: true };
      }
    }
  };
};

// теперь работает!
for (let num of range) {
  alert(num); // 1, затем 2, 3, 4, 5
}

Array.from - есть универсальный метод который принимает 
итерируемый объект или псевдомассив и делает из него «настоящий» 
Array. После этого мы уже можем использовать методы массивов.
Полный синтаксис Array.from позволяет указать необязательную 
«трансформирующую» функцию:
Array.from(obj[, mapFn, thisArg])
Необязательный второй аргумент может быть функцией, которая будет 
применена к каждому элементу перед добавлением в массив, а 
thisArg позволяет установить this для этой функции.


Map – это коллекция ключ/значение, как и Object. Но основное 
отличие в том, что Map позволяет использовать ключи любого типа.


    new Map() – создаёт коллекцию.
    map.set(key, value) – записывает по ключу key значение value.
    map.get(key) – возвращает значение по ключу или undefined, если ключ key отсутствует.
    map.has(key) – возвращает true, если ключ key присутствует в коллекции, иначе false.
    map.delete(key) – удаляет элемент (пару «ключ/значение») по ключу key.
    map.clear() – очищает коллекцию от всех элементов.
    map.size – возвращает текущее количество элементов.


Перебор Map :

    map.keys() – возвращает итерируемый объект по ключам,
    map.values() – возвращает итерируемый объект по значениям,
    map.entries() – возвращает итерируемый объект по парам вида [ключ, значение], этот вариант используется по умолчанию в for..of.

Object.fromEntries: Object из Map


Объект Set – это особый вид коллекции: «множество» значений 
(без ключей), где каждое значение может появляться только один раз.
Его основные методы это:

    new Set(iterable) – создаёт Set, и если в качестве аргумента был предоставлен итерируемый объект (обычно это массив), то копирует его значения в новый Set.
    set.add(value) – добавляет значение (если оно уже есть, то ничего не делает), возвращает тот же объект set.
    set.delete(value) – удаляет значение, возвращает true, если value было в множестве на момент вызова, иначе false.
    set.has(value) – возвращает true, если значение присутствует в множестве, иначе false.
    set.clear() – удаляет все имеющиеся значения.
    set.size – возвращает количество элементов в множестве.


    set.keys() – возвращает перебираемый объект для значений,
    set.values() – то же самое, что и set.keys(), присутствует для обратной совместимости с Map,
    set.entries() – возвращает перебираемый объект для пар вида [значение, значение], присутствует для обратной совместимости с Map.


WeakMap
Первое его отличие от Map в том, что ключи в WeakMap должны быть 
объектами, а не примитивными значениями:

В WeakMap присутствуют только следующие методы:

    weakMap.get(key)
    weakMap.set(key, value)
    weakMap.delete(key)
    weakMap.has(key)


WeakSet
Коллекция WeakSet ведёт себя похоже:
    Она аналогична Set, но мы можем добавлять в WeakSet только объекты (не примитивные значения).
    Объект присутствует в множестве только до тех пор, пока доступен где-то ещё.
    Как и Set, она поддерживает add, has и delete, но не size, keys() и не является перебираемой.


Object.keys, values, entries

Для простых объектов доступны следующие методы:

    Object.keys(obj) – возвращает массив ключей.
    Object.values(obj) – возвращает массив значений.
    Object.entries(obj) – возвращает массив пар [ключ, значение].

У объектов нет множества методов, которые есть в массивах, 
например map, filter и других. Если мы хотели бы их применить, 
то можно использовать Object.entries с последующим вызовом 
Object.fromEntries

let prices = {
  banana: 1,
  orange: 2,
  meat: 4,
};
let doublePrices = Object.fromEntries(
  // преобразовать в массив, затем map, затем fromEntries обратно объект
  Object.entries(prices).map(([key, value]) => [key, value * 2])
);
alert(doublePrices.meat); // 8


перебор с циклом .entries()

let user = {
  name: "John",
  age: 30
};

// цикл по ключам и значениям
for (let [key, value] of Object.entries(user)) {
  alert(`${key}:${value}`); // name:John, затем age:30

  обмен значениями:

  let guest = "Jane";
let admin = "Pete";

// Давайте поменяем местами значения: сделаем guest = "Pete", а admin = "Jane"
[guest, admin] = [admin, guest];

alert(`${guest} ${admin}`); // Pete Jane (успешно заменено!)



Если мы хотим не просто получить первые значения, но и собрать 
все остальные, то мы можем добавить ещё один параметр, который 
получает остальные значения, используя оператор «остаточные 
параметры» – троеточие ("..."):

let [name1, name2, ...rest] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];

// rest это массив элементов, начиная с 3-го
alert(rest[0]); // Consul
alert(rest[1]); // of the Roman Republic
alert(rest.length); // 2


Даты и время:

Для создания нового объекта Date нужно вызвать конструктор new Date() с одним из следующих аргументов:

new Date()
Без аргументов – создать объект Date с текущими датой и временем:

let now = new Date();
alert( now ); // показывает текущие дату и время


new Date(milliseconds)

    Создать объект Date с временем, равным количеству миллисекунд (тысячная доля секунды), прошедших с 1 января 1970 года UTC+0.


new Date(year, month, date, hours, minutes, seconds, ms)

    Создать объект Date с заданными компонентами в местном часовом поясе. Обязательны только первые два аргумента.

        year должен состоять из четырёх цифр. Для совместимости также принимаются 2 цифры и рассматриваются как 19xx, к примеру, 98 здесь это тоже самое, что и 1998, но настоятельно рекомендуется всегда использовать 4 цифры.
        month начинается с 0 (январь) по 11 (декабрь).
        Параметр date здесь представляет собой день месяца. Если параметр не задан, то принимается значение 1.
        Если параметры hours/minutes/seconds/ms отсутствуют, их значением становится 0.


Существуют методы получения года, месяца и т.д. из объекта Date:

getFullYear()
    Получить год (4 цифры)
getMonth()
    Получить месяц, от 0 до 11.
getDate()
    Получить день месяца, от 1 до 31, что несколько противоречит названию метода.
getHours(), getMinutes(), getSeconds(), getMilliseconds()
    Получить, соответственно, часы, минуты, секунды или миллисекунды. 

getDay()
    Вернуть день недели от 0 (воскресенье) до 6 (суббота). Несмотря на то, что в ряде стран за первый день недели принят понедельник, в JavaScript начало недели приходится на воскресенье. 

Однако существуют и их UTC-варианты, возвращающие день, месяц, год для временной зоны UTC+0: getUTCFullYear(), getUTCMonth(), getUTCDay(). Для их использования требуется после "get" подставить "UTC".
getTime()

    Для заданной даты возвращает таймстамп – количество миллисекунд, прошедших с 1 января 1970 года UTC+0.
getTimezoneOffset()

    Возвращает разницу в минутах между UTC и местным часовым поясом

Установка компонентов даты

Следующие методы позволяют установить компоненты даты и времени:

    setFullYear(year, [month], [date])
    setMonth(month, [date])
    setDate(date)
    setHours(hour, [min], [sec], [ms])
    setMinutes(min, [sec], [ms])
    setSeconds(sec, [ms])
    setMilliseconds(ms)
    setTime(milliseconds) (устанавливает дату в виде целого количества миллисекунд, прошедших с 01.01.1970 UTC)

У всех этих методов, кроме setTime(), есть UTC-вариант, например: setUTCHours().

Как мы видим, некоторые методы могут устанавливать сразу несколько компонентов даты, например: setHours. Если какая-то компонента не указана, она не меняется.


Автоисправление даты

Автоисправление – это очень полезная особенность объектов Date. Можно устанавливать компоненты даты вне обычного диапазона значений, а объект сам себя исправит.

Пример:

let date = new Date(2013, 0, 32); // 32 Jan 2013 ?!?
alert(date); // ...1st Feb 2013!

Существует особый метод Date.now(), возвращающий текущую метку времени.

Метод Date.parse(str) считывает дату из строки.

Формат строки должен быть следующим: YYYY-MM-DDTHH:mm:ss.sssZ, где:

    YYYY-MM-DD – это дата: год-месяц-день.
    Символ "T" используется в качестве разделителя.
    HH:mm:ss.sss – время: часы, минуты, секунды и миллисекунды.
    Необязательная часть 'Z' обозначает часовой пояс в формате +-hh:mm. Если указать просто букву Z, то получим UTC+0.


В Node.js для этого предусмотрен модуль microtime и ряд других способов. Технически почти любое устройство или среда позволяет добиться большей точности, просто её нет в объекте Date.

JSON:

JavaScript предоставляет методы:

    JSON.stringify для преобразования объектов в JSON.
    JSON.parse для преобразования JSON обратно в объект.

Полный синтаксис JSON.stringify:

let json = JSON.stringify(value, [replacer, space])

value
    Значение для кодирования.
replacer
    Массив свойств для кодирования или функция соответствия function(key, value).
space
    Дополнительное пространство (отступы), используемое для форматирования. 


Как и toString для преобразования строк, объект может предоставлять метод toJSON для преобразования в JSON. JSON.stringify автоматически вызывает его, если он есть.


Чтобы декодировать JSON-строку, нам нужен другой метод с именем JSON.parse.

Синтаксис:

let value = JSON.parse(str, [reviver]);

str
    JSON для преобразования в объект.
reviver
    Необязательная функция, которая будет вызываться для каждой пары (ключ, значение) и может преобразовывать значение. 









